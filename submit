#!/usr/bin/env python
# encoding: utf-8

"""
This script submits Q-Chem jobs to the queue
Authors: Daniel   Lambrecht (original)
         Benjamin Albrecht (rewritten)


New version requires Python 2.7+ (for argparse)
"""

import os, sys, grp, pwd, getpass, commands
from subprocess import call
from uuid import uuid4


try:
        import argparse
except ImportError:
        raise ImportError('Unable to import argparse, make sure you are using Python 2.7+')


def get_arguments(args=None):

    ### Default Settings ###
    # Determine default billing account
    # ... first, determine group(s) that the user belongs to
    # ... then pick the first group as the billing account (most likely the PI's # name)
    user = getpass.getuser()
    groups = [g.gr_name for g in grp.getgrall() if user in g.gr_mem]
    gid = pwd.getpwnam(user).pw_gid
    groups.append(grp.getgrgid(gid).gr_name)
    def_account = groups[0] # default billing account

    # Determine default Q-Chem version
    # We first try $QC environment variable, if that is not defined,
    # we assume we are on Frank and we pick the latest version of the Q-Chem trunk
    def_path = os.environ.get('QC')
    if not def_path:
        qchem_dir = '/home/dlambrecht/software'
        all_subdirs = [qchem_dir + "/" + d for d in os.listdir(qchem_dir) if not os.path.isfile(d) and "qchem" in d and "trunk" in d]
        latest_subdir = max(all_subdirs, key=os.path.getmtime)
        def_path = latest_subdir # default version

    # Argparse stuff
    parser = argparse.ArgumentParser(prog='submit',
                                     usage= "%(prog)s job [options] ",
                                     description = ''' %(prog)s is a script that auto-generates a pbs
                                     file and submits a job, utilizing another script, best_queue, which determines
                                     the best queue to submit for minimizing wait times '''
                                    )


    parser.add_argument('job', help='Fil')
    parser.add_argument('--ppn',      type=int,  default=1, help='number of processors')
    parser.add_argument('--nodes',    type=int,  default=1, help='number of nodes')
    parser.add_argument('--queue',    type=str,  default='auto')
    parser.add_argument('--walltime', type=str,  default='1:00:00')
    parser.add_argument('--qos',      type=str,  default='low', help='priority')
    parser.add_argument('--account',  type=str,  default=def_account )
    parser.add_argument('--path',     type=str,  default=def_path)
    parser.add_argument('--save',     type=bool, default=False)
    parser.add_argument('--dry',      type=bool, default=False)
    parser.add_argument('--investor', type=bool, default=True)

    opts = parser.parse_args(args)

    return opts


def main():
    # Get arguments using argparse
    opts = get_arguments()
    ifile = opts.job

   # Settings = {'-ppn': '1',
   #             '-nodes': '1',
   #             '-queue': 'auto',
   #             '-walltime': '1:00:00',
   #             '-qos': 'low',
   #             '-account': def_account,
   #             '-path': def_path,
   #             '-save': 'off',
   #             '-dry': 'off',
   #             '-investor': True
   # }


#    ### Print USAGE information ###
#    USAGE = "\n \
#    Usage:  submit  input-file [options] \n \
#    \n \
#    OPTIONS: \n \
#                    -nodes      #nodes \n \
#                    -ppn        #cores_per_node \n \
#                    -queue      queue (default: select 'best' queue automatically)\n \
#                    -walltime   [dd:]hh:mm:mm \n \
#                    -qos        reduce billing for low priority jobs (default: " + Settings['-qos'] + ") \n \
#                    -path       qchem_path (default: " + Settings['-path'] + ") \n \
#                    -account    billing account (default: " + Settings['-account'] + ") \n \
#                    -save       save scratch data \n \
#                    -dry        only create run script, don't submit \n \
#                    -print      print default values for all options \n \
#    "
#
#    if len(sys.argv) < 2:
#        print USAGE
#        sys.exit(1)

    # TODO: Pick best queue for job type and available resources


#    if "-print" in sys.argv:
#        print "Default values:"
#        for key in Settings:
#          print "  ", key, " = ", Settings[key]
#        sys.exit(0)


    # Read in command line arguments
    #my_name = sys.argv.pop(0)
    #print "my_name = ", my_name
    #ifile = sys.argv.pop(0)
    #print "ifile = ", ifile

    #for i in range( 0, len(sys.argv), 2 ):
    #    arg = sys.argv[i]
    #    val = sys.argv[i+1]
    #    #print "arg = ", arg
    #    #print "val = ", val
    #    if arg in Settings:
    #        Settings[arg] = val
    #    else: # TODO this doesn't seem to work yet
    #        print arg + ": Invalid option."
    #        sys.exit(1)

    # Create job name
    job_name = ifile.replace(".in", "")
    job_name = job_name.replace(".n", "")
    print "job name = ", job_name


    # Automatic selection of submission queue
    if opts.queue == "auto":

        settings = ""

        status = commands.getstatusoutput('best_queue ' + settings)
        if "sh:" in status[1]:
            print "Error running best_queue script:"
            print status
            sys.exit(1)

        output = str(status[1]).split("\n")


        queue = output[0].split()[0]
        wait = 1
        #wait = output[0].split()[4]
        print output

        # Signal that we're 'investors' on Frank
        if opts.investor == True:
            if not queue == "test":
                queue = "i" + queue

        print "Best submission queue: ", queue
        print "Estimated wait time: ", wait

        opts.queue = queue



    # Create unique ID for job
    JOB_ID = uuid4().hex # a unique id for the current job
    RUN = ".run.sh_" + JOB_ID
    #print "run script = ", RUN


    # Write submission script
    file = open(RUN, "w")

    file.write("#!/bin/bash\n")
    file.write("\n")
    file.write("#PBS -N " + job_name + "\n")
    file.write("#PBS -l nodes=" + str(opts.nodes) + ":ppn=" + str(opts.ppn) + "\n")
    file.write("#PBS -l walltime=" + opts.walltime + "\n")
    file.write("#PBS -q " + opts.queue + "\n")
    file.write("#PBS -l qos=" + opts.qos + "\n")
    file.write("#PBS -A " + opts.account + "\n")
    file.write("\n")
    file.write("JOBNAME=" + job_name + "\n")
    file.write("NODES=" + str(opts.nodes) + "\n")
    file.write("PPN=" + str(opts.ppn) + "\n")
    file.write("\n")
    file.write("cp ${PBS_O_WORKDIR}/${JOBNAME}.in ${LOCAL}\n")
    file.write("cd ${LOCAL}\n")
    file.write("\n")
    file.write("# Load Q-Chem environment variables ...\n")
    file.write(". " + opts.path + "/qcrc\n")
    file.write("\n")

    parallel_string = ""
    if int(opts.nodes) > 1:
        total_cores = str( int(opts.nodes) * int(opts.ppn) )
        parallel_string = "-np " + opts.nodes + " -nt " + opts.ppn
    elif int(opts.ppn) > 1:
        parallel_string = "-nt ${PPN}"

    save_string = ""
    if opts.save == True:
        save_string = " -save "

    #file.write("touch ${JOBNAME}.out\n")
    #file.write("ln ${JOBNAME}.out ${PBS_O_WORKDIR}/${JOBNAME}.out\n")
    file.write("\n")
    file.write("qchem " + parallel_string + save_string + " ${JOBNAME}.in ${PBS_O_WORKDIR}/${JOBNAME}.out ${JOBNAME}." + JOB_ID + "\n")
    file.write("\n")

    if opts.save == True:
        file.write("cp -r ${LOCAL}/* ${PBS_O_WORKDIR}/\n")

    file.write("rm ${PBS_O_WORKDIR}/" + RUN + "\n")

    file.close()

    #qsub ${RUN}
    if opts.dry == False:
        call(["qsub", RUN])

if __name__ == '__main__':
    main()
