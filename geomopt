#!/usr/bin/env python
"""Had to write my own parser because cclib can't read broken outputs """
from __future__ import print_function
from argparse import ArgumentParser
from os import path

class geomopt(object):
    def __init__(self, fname):
        self.filelength = self.file_len(fname)
        self.idx = 0
        self.atomcoords_list = []
        self.atomelements = []
        self.inputcommands_list = []

        self.parse(fname)

    def file_len(self, fname):
        """Most efficient way I know to get a file length"""
        with open(fname) as f:
            for i, l in enumerate(f):
                pass
        return i + 1

    def parse(self, fname):
        """Parse geometries and inputs out of file"""
        with open(fname, 'r') as self.handle:
            while self.idx < self.filelength:
                line = self.nextline()
                self.parseinput(line)
                self.parsegeometry(line)

    def parseinput(self, line):
        """Parse inputs"""
        if 'User input:' in line:
            dashes = '--------------------------------------------------------------'
            line = self.nextline()
            if dashes in line:
                inputcommands = []
                while True:
                    line = self.nextline()
                    if not dashes in line:
                        inputcommands.append(line)
                    else: break
                self.inputcommands_list.append(inputcommands)

    def parsegeometry(self, line):
        """Parse geometries"""
        if 'Standard Nuclear Orientation (Angstroms)' in line:
            line = self.nextline(3)
            atomcoords = []
            atomelements = []
            while list(set(line.strip())) != ['-']:
                entry = line.split()
                atomelements.append(entry[1])
                atomcoords.append(list(map(float, entry[2:])))
                line = self.nextline()
            if not self.atomelements:
                self.atomelements = atomelements

            self.atomcoords_list.append(atomcoords)

    def nextline(self, num=1):
        """Cleaner nextline"""
        for x in range(num):
            line = self.handle.readline()
            self.idx += 1
        return line

    def printinput(self):
        """Print stuff"""
        atom_template = '{:3s} {:15.10f} {:15.10f} {:15.10f}'
        atomcoords = self.atomcoords_list[-1]
        separator = ''
        for inputcommands in self.inputcommands_list:
            i = 0
            print(separator, end='')
            while i < len(inputcommands):
                if '$molecule' in inputcommands[i] and not 'read' in inputcommands[i+1]:
                    print(inputcommands[i], end='')
                    print(inputcommands[i+1], end='')
                    for element, (x, y, z) in zip(self.atomelements, atomcoords):
                        print(atom_template.format(element, x, y, z))
                    i += len(self.atomelements) + 1
                else:
                    print(inputcommands[i], end='')
                i += 1
            separator = '\n@@@\n'

    def writeinput(self, inputfilename):
        """Write stuff"""
        atom_template = '{:3s} {:15.10f} {:15.10f} {:15.10f}'
        atomcoords = self.atomcoords_list[-1]
        separator = ''
        with open(inputfilename, 'w') as finp:
            for inputcommands in self.inputcommands_list:
                i = 0
                finp.write(separator)
                while i < len(inputcommands):
                    if '$molecule' in inputcommands[i] and not 'read' in inputcommands[i+1]:
                        finp.write(inputcommands[i])
                        finp.write(inputcommands[i+1])
                        for element, (x, y, z) in zip(self.atomelements, atomcoords):
                            finp.write(atom_template.format(element, x, y, z) + '\n')
                        i += len(self.atomelements) + 1
                    else:
                        finp.write(inputcommands[i])
                    i += 1
                separator = '\n@@@\n'


    def newgeometry(self):
        """Replace old geometry in inputfile with new geometery"""
        self.atomcoords_list = []
        self.atomelements = []
        self.inputcommands_list = []


def get_arguments(args=None):
    parser = ArgumentParser(prog='geomopt',
            usage='geomopt [options] outputfilename',
            description='Resumes a failed Q-Chem geom-opt calc')

    parser.add_argument('outputfilename', help='Q-Chem outputfile name')
    parser.add_argument('-o', nargs='*', default=-1,
                        help='Write to new inputfile, give no filename for default indexed naming')

    opts = parser.parse_args(args)
    return opts

def get_integer(s):
    """Quick way to see if file is already indexed"""
    try:
        num = int(s)
        return num
    except ValueError:
        return 1

if __name__ == '__main__':
    opts = get_arguments()
    geom = geomopt(opts.outputfilename)

    # Design Flaw or Feature... User can never use filename '-1'
    if not opts.o == -1:
        if opts.o:
            # Write to inputfiles designated
            for inputfile in opts.o:
                geom.writeinput(inputfile)
        else:
            # Write to indexed name based on output name
            stub, ext = path.splitext(opts.outputfilename)
            idx = get_integer(list(stub)[-1])
            while path.isfile(stub+str(idx)+'.qcm'):
                idx += 1
            fname = stub+str(idx)+'.qcm'
            print("Wrote new inputfile to ", fname)
            geom.writeinput(fname)
    else:
        # Print to STDOUT
        geom.printinput()

